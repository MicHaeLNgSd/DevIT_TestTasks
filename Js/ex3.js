//Напишите функцию обертку, которая на вход принимает массив функций и их параметров, 
//а возвращает массив результатов их выполнения. Количество аргументов 
//TODO исполняемой функции не ограничено!

// Створюємо асинхронну функцію bulkRun, яка приймає масив functionsAndArgs,
// де кожен елемент - це масив, що містить функцію та її аргументи. Функція повертає масив результатів виконання цих функцій.
async function bulkRun(functionsAndArgs) {
  // Створюємо масив для зберігання результатів.
  const results = [];

  // Ітеруємося через кожну пару [функція, аргументи] у масиві functionsAndArgs.
  for (const [func, args] of functionsAndArgs) {
    // Очікуємо завершення виконання функції, використовуючи обгортку Promise.
    await new Promise((resolve) => {
      // Викликаємо функцію з аргументами та callback-функцією.
      func(...args, (data) => {
        // Додаємо результат виконання функції до масиву результатів.
        results.push(data);
        // Викликаємо resolve, щоб визначити, що завдання завершилося.
        resolve();
      });
    });
  }

  // Повертаємо масив результатів виконання функцій.
  return results;
}

// Створюємо три функції f1, f2, f3, кожна з яких має callback-функцію.
const f1 = (cb) => { cb(1) };
const f2 = (a, cb) => { cb(a) };
const f3 = (a, b, cb) => { setTimeout(() => cb([a, b]), 1000) };

// Викликаємо функцію bulkRun, передаючи масив пар [функція, аргументи] для виконання.
bulkRun([
  [f1, []],           // Викликаємо f1 без аргументів, передаючи 1 в якості результату.
  [f2, [2]],          // Викликаємо f2 з аргументом 2, передаючи 2 в якості результату.
  [f3, [3, 4]]        // Викликаємо f3 з аргументами 3 та 4, результат повернеться через 1 секунду.
]).then(console.log); // Виводимо результати в консоль. Очікуємо [1, 2, [3, 4]].